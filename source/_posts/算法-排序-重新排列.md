---
title: 算法-排序-重新排列.
date: 2023-05-18 19:30:00
categories: 排序
tags: 算法
---

### 算法-排序-重新排列

#### 题

给定一个字符串 s，s 包括以空格分隔的若干个单词，请对 s 进行如下处理后输出

1.  单词内部调整:对每个单词字母重新按 字典序排序
2.  单词间顺序调整:

        1. 统计每个单词出现的次数，并按次数 降序排列
        2. 次数相同，按 单词长度Q升序排列
        3. 次数和单词长度均相同，按字典升序排列
        请输出处理后的字符串，每个单词以一个空格分隔。

    输入描述
    行字符串，每个字符取值范围: [a-ZA-Z0-9]以及空格,，字符串长度范围:[1，1000]
    输出描述
    输出处理后的字符串，每个单词以一个空格分隔.
    用例
    | 输入 | My sister is in the house not in the yard|
    |----|----|
    | 输出 | in in eht eht My is not adry ehosu eirsst |
    | 说明 | 无 |

#### 解

```
 let str = 'My sister is in the house not in the yard'
 <!-- 分割成数组 -->
let arr = str.split(' ')
<!-- 对每个单词字母进行排序 -->
arr = arr.map((item) =>{
  return  [...item].sort().join('')
})


let arr2 = []
let obj ={}
<!-- 设置成对象让他进行累加 -->
arr2 = arr.reduce((p,c)=>{
    p[c] ? p[c]++ : p[c]=1;
    return p;
},{})

console.log(arr2)
<!-- 对已经排序一次的数组进行二次排序 -->
arr= arr.sort( (a,b) =>{
    <!-- 如果单词出现次数不一样 -->
    if(arr2[b] !==arr2[a]){
        <!-- 就先按照出现次数排序 -->
     return   arr2[b] - arr2[a]
       <!-- 如果出现次数一样先按照长度排序 -->
    }else  if(a.length !== b.length){
        <!-- 因为要是降序所以小的在前面 -->
           return a.length -b.length
            <!--  如果次数长度都一样那就对比字典排序-->
        }else if(a > b){
                return 1
            }else{
                return -1
            }

} )
  console.log(arr.join(' '))
```
