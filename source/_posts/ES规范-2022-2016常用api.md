---
title: ES2022-ES2016常用api
date: 2023-04-28 19:30:00
categories: ES规范
tags: 知识总结
---

### ES13(2022)

#### 1. 类型字段声明

在 ES13 之前，类字段只能在构造函数中声明，

```

  class Str{
    str ='123' // 不允许
    constructor(name,age){// 构造函数
        // 定义声明只能在构造函数中声明
       this.name = name
       this.age = age

    }

  }
```

在 ES13 中取消了这个限制，

```
    class Str{
      color = 'blue';
      age = 2;
      name ='张三'
    }

```

#### 2. 私有方法和字段

使用 ES13，我们现在可以将私有字段和成员添加到类中。在方法字段中前加入#号就是私有变量不可被外部访问

```
  class Str{
      #color = 'blue';
      #age = 2;
      name ='张三'
    }

```

#### 3. 静态类字段和静态私有方法

在字段和方法前加入 static 修饰符就能定义静态字段和方法

```
     class Str{
          static name = 'zhangsan'
          static fun (){
            this.name= 'zhaosi'
          }
     }


```

#### 4. at()方法进行索引

```
    const arr =[1,2,3,4,5]
    console.log(arr.at(-1)) // 5
    console.log(arr.at(-2)) // 4
    console.log(arr.at(1)) // 2


    const str ='abcdefg'
    console.log(str.at(-1)) // f
    console.log(str.at(1)) // b
    console.log(str.at(0)) // a

```

#### 5. findLast() 从数组的末尾开始查找

findLast() 从数组的末尾开始查找与 find()方法使用一至，只是从末尾开始查找

```
  const arr = [10,20,30,40,50]
  console.log(arr.find(e => e==10)) // 10
  console.log(arr.findLast(e => e==40)) // 10 从末尾开始查找

```

#### 6. findLastIndex() 从末尾开始查找返回下标

findLastIndex() 从末尾开始查找返回下标

```
    const arr = [10,20,30,40,50]
    console.log(arr.findIndex(e => e==10)) // 0
    console.log(arr.findLastIndex(e => e==40)) // 3

```

#### 7. hasOwn() 判断对象中是否有该属性

使用 Object.hasOwn()可以判断目标对象中是否有对应的属性返回 true 或者 false

```
  let obj = {
    name ='zhansan'
  }
console.log(Objeact.hasOwn(obj,'nmae')) // true
console.log(Objeact.hasOwn(obj,'age')) // false


```

### ES12(2021)

#### 1. replaceAll 全部替换

新的字符串方法，可以替换全部的

```
  let str = 'javaScript'
  console.log(str.replaceAll('a','v')) // jvvvScript

```

#### 2. Promise.any() Promise 的短路返回

只要有一个 promise 完成，就会短路返回一个值，如果所有的都失败了就会抛出错误汇总

```
  let p1 = new Promise((resolve，reject)=> setTimeout（reject,200,'张三'）)
  let p2 = new Promise((resolve，reject)=> setTimeout（rresolve，reject,2000,'李四'）)
  let p3 = new Promise((resolve，reject)=>setTimeout（ resolve，reject,3000,'王五'）)
    Promise.any([p1,p2,p3]).then(value =>{
      console.log(value) //李四
    }).catch()

```

### ES11(2020)

#### 1. 可选链操作符

可选链是访问对象的时候使用，不用担心属性是否存在，如果存在继续执行，不存在直接返回 undefined 不会报错

```
 let obj ={
        name:'zhangsan',
        age:{

        }
 }
    console.log(obj?.name) //zhangsan
    console.log(obj?.age?.name) //undefined
```

#### 2. Promise.allSettled

Promise.allSettled 方法接受一组 Promise，并且会返回所以的结果不管是成功还是失败

```
  const arr=[Promise.resolve(100),Promise.resolve(null),Promise.reject('失败')]
  Promise.allSettled(arr).then(results =>{
          console.log(results) // [{status:"fulfilled",value:100},{status:"fulfilled",value:null},{status:"rejected",value:'失败'}]
  })
```

#### 3. 空值合并符

当左边操作数未定义或为空时，该操作符将返回右边操作数

```
  let name
  console.log(name ?? '张三') // 张三
  console.log(name || '张三') // 张三

  let name=null
  console.log(name ?? '张三') // 张三
  console.log(name || '张三') // 张三

  let name=NaN
  console.log(name ?? '张三') // NaN
  console.log(name || '张三') // 张三

  let name=0
  console.log(name ?? '张三') // 0
  console.log(name || '张三') // 张三

  let name=false
  console.log(name ?? '张三') // false
  console.log(name || '张三') // 张三

  let name=''
  console.log(name ?? '张三') // ''
  console.log(name || '张三') // 张三

```

### ES10(2019)

#### 1. Object.entries()

作用是将对象转为数组

```
 let obj = {name:'张三',age'15'}
 console.log(Object.entries(obj)) // [['name',"张三"],['age','15']]

```

#### 2. Object.fromEntries()

作用是将数组转为对象

```
 let arr =[['name',"张三"],['age','15']]
 console.log(Object.fromEntries(arr)) // {name:'张三',age'15'}

```

#### 3. flat()

数组扁平化

```
  let arr = [[1,2,3]]
  console.log(arr.flat()) // [1,2,3]
  //多层嵌套传入Infinity可以全部拉平
  let arr = [1,[2,[3,[4]]]]
   console.log(arr.flat(Infinity)) // [1,2,3,4]

```

#### 4. flatMap()

将数组遍历之后拉平

```
  let arr = ['今天',"",'早上']
  arr.map(s =>s.split('')) //[["今","天"],[],["早","上"]]
  arr.flatMap(s =>s.split('')) //["今","天","早","上"]
```

### ES9(2018)

#### 1. 异步迭代

异步迭代是以串行的方式运行异步操作

```
  async function process(arr){
      for await(let i of arr){
          doSomething(i)
      }
  }

```

#### 2. Promise.finally()

不管成功还是失败都会执行的方法，常见的有 loading 的取消。

```
  getList().then().catch().finally()

```

#### 3. (...)拓展运算符

在 ES6 中我们就已经有拓展运算符了但是呢。只针对数组在 ES9 中将其完善能够在对象中使用

```
   let a ={a:1,b:2}
   let b ={c:3,...a} // {a:1,b:2,c:3}
```

### ES8(2017)

#### 1. Object.values()

返回对象可枚举属性值的数组

```
  let obj ={a:1,b:2}
  Object.values(obj) // [1,2]
```

### ES7(2016)

#### includes()

数组查询方法，包含元素返回 true 不包含返回 false

```
['a', 'b', 'c'].includes('a') // true
['a', 'b', 'c'].includes('d') // false
```

#### 幂运算符\*\*

幂运算符\*\*

```
6**2 // 36
```
